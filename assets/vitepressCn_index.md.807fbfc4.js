import{_ as e,o as s,c as t,R as a}from"./chunks/framework.af956f17.js";const v=JSON.parse('{"title":"VitePress中文文档","description":"VitePress中文文档","frontmatter":{"title":"VitePress中文文档","description":"VitePress中文文档","tags":["VitePress中文文档"]},"headers":[],"relativePath":"vitepressCn/index.md"}'),r={name:"vitepressCn/index.md"},i=a('<h1 id="vitepress-是什么" tabindex="-1">VitePress 是什么？ <a class="header-anchor" href="#vitepress-是什么" aria-label="Permalink to &quot;VitePress 是什么？&quot;">​</a></h1><p>VitePress 是建立在Vite之上的 和 VuePress 兄弟关系。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>VitePress 目前处于 alpha 状态。它已经适合于开箱即用的文档站点使用，但配置和主题化的 API 仍可能在小版本之间发生变化。</p></div><h2 id="目的" tabindex="-1">目的 <a class="header-anchor" href="#目的" aria-label="Permalink to &quot;目的&quot;">​</a></h2><details class="details custom-block"><summary>原文</summary><p>We love VuePress v1, but being built on top of Webpack, the time it takes to spin up the dev server for a simple doc site with a few pages is just becoming unbearable. Even HMR updates can take up to seconds to reflect in the browser!</p></details><p>我们都喜欢使用 VuePress v1，但由于是建立在 Webpack 的基础之上，即使是一个只有几个页面的文档网站来说，启动开发服务器所需要花费的时间也会变的让人难以忍受。</p><details class="details custom-block"><summary>原文</summary><p>Fundamentally, this is because VuePress v1 is a Webpack app under the hood. Even with just two pages, it&#39;s a full on Webpack project (including all the theme source files) being compiled. It gets even worse when the project has many pages – every page must first be fully compiled before the server can even display anything!</p></details><p>从根本上说，这是因为 VuePress v1 是一个 Webpack 应用程序的引擎。即使只有两个页面，它也是一个完整的 Webpack 项目（包括所有的主题源文件）被编译。当项目有很多页面时，每一个页面都必须首先被完全编译，然后服务器才可以显示一些内容，这样会让情况就更糟糕！</p><details class="details custom-block"><summary>原文</summary><p>Incidentally, Vite solves these problems really well: nearly instant server start, an on-demand compilation that only compiles the page being served, and lightning-fast HMR. Plus, there are a few additional design issues I have noted in VuePress v1 over time but never had the time to fix due to the amount of refactoring it would require.</p></details><p>顺便说一句，Vite 很好地解决了这些问题：几乎是即时启动服务器，按需编译，只编译正在提供的页面，以及快如闪电的 HMR。另外，在 VuePress v1 中，我还注意到一些额外的设计问题，但由于需要大量的重构，所以一直没有时间去解决。</p><details class="details custom-block"><summary>原文</summary><p>Now, with Vite and Vue 3, it is time to rethink what a &quot;Vue-powered static site generator&quot; can really be.</p></details><p>现在有了 Vite 和 Vue 3，是时候重新思考什么是&quot;由 Vue 驱动的静态网站生成器&quot;了。</p><h2 id="对比-vuepress-v1-的改进" tabindex="-1">对比 VuePress v1 的改进 <a class="header-anchor" href="#对比-vuepress-v1-的改进" aria-label="Permalink to &quot;对比 VuePress v1 的改进&quot;">​</a></h2><p>相当于 VuePress v1 有几处得到了改进...</p><h3 id="使用了-vue-3" tabindex="-1">使用了 Vue 3 <a class="header-anchor" href="#使用了-vue-3" aria-label="Permalink to &quot;使用了 Vue 3&quot;">​</a></h3><details class="details custom-block"><summary>原文</summary><p>Leverages Vue 3&#39;s improved template static analysis to stringify static content as much as possible. Static content is sent as string literals instead of JavaScript render function code – the JS payload is therefore much cheaper to parse, and hydration also becomes faster.</p></details><p>利用 Vue 3 改进的模板静态分析能力，尽可能地将静态内容字符串化。静态内容以字符串文本形式发送，而非 JavaScript 渲染函数代码，因此，JS 有效载荷的解析成本更低，hydration 也开始变得更快。</p><div class="tip custom-block"><p class="custom-block-title">译者注</p><p>不清楚 hydration 到底是什么意思，特意查了一下。</p><p>网上查到的资料：<a href="https://blog.csdn.net/qq_41800366/article/details/117738916" target="_blank" rel="noreferrer">hydration 代表的是给对象填充数据的这一过程</a>。</p><p>然后在 Vue 的官方英文版中也找到了<a href="https://vuejs.org/guide/scaling-up/ssr.html#client-hydration" target="_blank" rel="noreferrer">hydration</a>，对比<a href="https://cn.vuejs.org/guide/scaling-up/ssr.html#client-hydration" target="_blank" rel="noreferrer">中文版</a>发现官方翻译为“激活”的意思。</p><p>在激活过程中，Vue 会创建一个与服务端完全相同的应用实例，然后将每个组件与它应该控制的 DOM 节点相匹配，并添加 DOM 事件监听器。</p><p>同时在掘金上咨询了一下，有人给出的解释为：<a href="https://juejin.cn/pin/7135598417903878157" target="_blank" rel="noreferrer">这是同构渲染中的概念，在服务器上脱水，传到浏览器注水</a></p></div><details class="details custom-block"><summary>原文</summary><p>Note the optimization is applied while still allowing the user to freely mix Vue components inside markdown content – the compiler does the static/dynamic separation for you automatically and you never need to think about it.</p></details><p>在应用优化的同时，你会发现仍然允许用户在 markdown 内容中自由混合 Vue 组件，编译器自动为你做静态/动态分离，你永远不需要考虑这个问题。</p><h3 id="内部使用了-vite-引擎" tabindex="-1">内部使用了 Vite 引擎 <a class="header-anchor" href="#内部使用了-vite-引擎" aria-label="Permalink to &quot;内部使用了 Vite 引擎&quot;">​</a></h3><ul><li>更快的 dev 开发服务器启动 Faster dev server start</li><li>更快的热更新 Faster hot updates</li><li>更快的打包（内部使用了了 Rollup）Faster build (uses Rollup internally)</li></ul><h3 id="更轻的页面权重" tabindex="-1">更轻的页面权重 <a class="header-anchor" href="#更轻的页面权重" aria-label="Permalink to &quot;更轻的页面权重&quot;">​</a></h3><p>Vue 3 tree-shaking + Rollup 代码分割</p><details class="details custom-block"><summary>原文</summary><ul><li>Does not ship metadata for every page on every request. This decouples page weight from total number of pages. Only the current page&#39;s metadata is sent. Client side navigation fetches the new page&#39;s component and metadata together.</li><li>Does not use vue-router because the need of VitePress is very simple and specific - a simple custom router (under 200 LOC) is used instead.</li></ul></details><ul><li><p>不在每个请求中为每个页面提供元数据。这使页面权重与总页数脱钩。只有当前页面的元数据被发送。客户端导航同时获取新页面的组件和元数据。</p></li><li><p>不使用 vue-router，因为 VitePress 的需求非常简单和具体，使用一个简单的自定义路由器（低于200 LOC）来代替。</p></li></ul><h3 id="其它差异" tabindex="-1">其它差异 <a class="header-anchor" href="#其它差异" aria-label="Permalink to &quot;其它差异&quot;">​</a></h3><details class="details custom-block"><summary>原文</summary><p>VitePress is more opinionated and less configurable: VitePress aims to scale back the complexity in the current VuePress and restart from its minimalist roots.</p><p>VitePress is future oriented: VitePress only targets browsers that support native ES module imports. It encourages the use of native JavaScript without transpilation, and CSS variables for theming.</p></details><p>VitePress 配置更加鲜明简洁：VitePress 目标是缩减当前 VuePress 的复杂性，并从根源上以极简的方式实现。</p><p>VitePress 是面向未来的：VitePress 只支持允许本地 ES 模块导入的浏览器。它鼓励使用本地 JavaScript 而不进行转译，并使用 CSS 变量进行主题化。</p><h2 id="这将会成为下一个-vuepress-吗" tabindex="-1">这将会成为下一个 vuepress 吗？ <a class="header-anchor" href="#这将会成为下一个-vuepress-吗" aria-label="Permalink to &quot;这将会成为下一个 vuepress 吗？&quot;">​</a></h2><details class="details custom-block"><summary>原文</summary><p>We already have <a href="https://github.com/vuepress/vuepress-next" target="_blank" rel="noreferrer">vuepress-next</a>, which would be the next major version of VuePress. It also makes lots of improvements over VuePress v1, and also supports Vite now.</p><p>VitePress is not compatible with the current VuePress ecosystem (mostly themes and plugins). The overall idea is that VitePress will have a drastically more minimal theming API (preferring JavaScript APIs instead of file layout conventions) and likely no plugins (all customization is done in themes).</p><p>There is an <a href="https://github.com/vuejs/vitepress/discussions/548" target="_blank" rel="noreferrer">ongoing disccussion</a> about this topic. If you&#39;re curious, please leave your thoughts!</p></details><p>我们已经有了 <a href="https://github.com/vuepress/vuepress-next" target="_blank" rel="noreferrer">vuepress-next</a>，这将是 VuePress 的下一个主要版本。它也比 VuePress v1 做了很多改进，而且现在也支持 Vite。</p><p>VitePress 与当前的 VuePress 生态系统（主要是主题和插件）不兼容。总的想法是，VitePress 将有一个大幅减少的主题 API（倾向于 JavaScript APIs 而不是文件布局惯例），并且可能没有插件（所有的定制都在主题中完成）。</p><p>关于这个问题，目前正在进行<a href="https://github.com/vuejs/vitepress/discussions/548" target="_blank" rel="noreferrer">讨论</a>。如果你感到好奇，请留下你的想法。</p>',35),o=[i];function l(n,u,p,c,d,h){return s(),t("div",null,o)}const b=e(r,[["render",l]]);export{v as __pageData,b as default};
