import{_ as a,o as e,c as i,R as o}from"./chunks/framework.af956f17.js";const k=JSON.parse('{"title":"浏览器页面的保护机制--同源策略","description":"","frontmatter":{},"headers":[],"relativePath":"studyCn/Network/XSSAndSRF.md"}'),t={name:"studyCn/Network/XSSAndSRF.md"},l=o('<h1 id="浏览器页面的保护机制-同源策略" tabindex="-1">浏览器页面的保护机制--同源策略 <a class="header-anchor" href="#浏览器页面的保护机制-同源策略" aria-label="Permalink to &quot;浏览器页面的保护机制--同源策略&quot;">​</a></h1><p>同源策略指的是我们访问站点的：<code>协议</code>、<code>域名</code>、`端口号 一致才叫同源，有一个不一样，都会被认为是跨源（跨域）。</p><p>浏览器默认同源站点之间是可以互相访问资源和操作 DOM 的，而不同元源之间想要互相访问资源或者操作 DOM 的话，就需要添加一些安全策略的限制。如下：</p><ol><li><p>DOM 层面：不同源站点之间不能互相访问和操作 DOM。</p></li><li><p>数据层面：不能获取不同源站点的 Cookie、LocalStorage、indexDB 等数据。</p></li><li><p>网络层面：不能通过 XMLHttpRequest 向不同源站点发送请求。（后来基于 CORS 可以实现但是也会存在一定的限制）</p></li></ol><p>当然，同源策略也不是绝对隔离不同源的站点，比如 link、img、script 标签都没有跨域限制，这也导致了一些安全问题。如 XSS 攻击和 CSRF 攻击</p><h2 id="xss-跨站脚本攻击" tabindex="-1">XSS（跨站脚本攻击） <a class="header-anchor" href="#xss-跨站脚本攻击" aria-label="Permalink to &quot;XSS（跨站脚本攻击）&quot;">​</a></h2><p>XSS 叫跨站脚本攻击，原本应该叫 CSS，但是为了和层叠样式区别开，叫 XSS。XSS 攻击是一种代码注入攻击，通过恶意注入 JS 脚本在浏览器运行，然后调取用户信息。</p><p>造成 XSS 攻击本质上还是因为网站没有过滤恶意代码。当恶意代码混入正常代码中一起执行时，浏览器没有办法分辨哪些是可信的，然后导致恶意代码也被执行。引起的危害有：</p><ul><li><p>页面数据或用户信息被窃取。如 Cookie、LocalStorage、DOM 等。</p></li><li><p>修改 DOM。比如伪造登陆窗口或在页面生成浮窗广告。</p></li><li><p>监听用户行为。如添加 addEventListener 来监听键盘事件，获取用户密码。</p></li><li><p>流量被劫持向其他网站。用户刚进入一个网站，就直接跳转到另外一个网站上。</p></li></ul><p>XSS 攻击有三种类型：存储型、反射型、DOM 型。</p><h3 id="存储型" tabindex="-1">存储型 <a class="header-anchor" href="#存储型" aria-label="Permalink to &quot;存储型&quot;">​</a></h3><p>存储型 XSS 攻击主要是将恶意脚本存储到服务端，当读取到该恶意脚本时，浏览器就会识别为一段 JS 代码来执行。比如在评论区，有人写了一段恶意脚本并提交，恶意脚本就会被服务器存储到数据库。当别人访问时，加载这段评论，浏览器就把它识别为 JS 代码来执行。</p><h3 id="反射型" tabindex="-1">反射型 <a class="header-anchor" href="#反射型" aria-label="Permalink to &quot;反射型&quot;">​</a></h3><p>通过 URL 参数注入恶意脚本，经服务器解析并响应后，凭借在 HTML 中传回浏览器，然后浏览器解析时就会执行恶意脚本。比如打开包含恶意脚本的链接，打开后会向服务器发送请求，服务器会获取 URL 中的数据然后凭借在 HTML 上返回，然后执行。它和存储型的区别在于不会存储在服务器中。</p><h3 id="基于-dom-型" tabindex="-1">基于 DOM 型 <a class="header-anchor" href="#基于-dom-型" aria-label="Permalink to &quot;基于 DOM 型&quot;">​</a></h3><p>通过一定的手段在网页向服务端请求资源时，劫持并修改页面的数据，插入恶意代码。</p><h2 id="解决方法" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法" aria-label="Permalink to &quot;解决方法&quot;">​</a></h2><ul><li>在服务端对 script 标签进行转义或过滤，再传回给浏览器，这样浏览器在 HTML 解析时就不会把 script 标签当作 JS 代码执行了。</li></ul><p>利用 http-only。当 Cookie 设置 http-only 后，会禁止 JavaScript 来访问 Cookie。</p><ul><li>充分利用 CSP。内容安全策略（CSP）是一个额外的安全层，会限制加载其他域下的资源文件、禁止向第三方提交数据。</li></ul><h1 id="csrf-跨站请求伪造" tabindex="-1">CSRF（跨站请求伪造） <a class="header-anchor" href="#csrf-跨站请求伪造" aria-label="Permalink to &quot;CSRF（跨站请求伪造）&quot;">​</a></h1><p>CSRF 是跨站请求伪造攻击，顾名思义，就是第三方利用用户的登录信息伪造成用户发起跨域请求。比如邮箱里的乱七八糟链接，打开链接的时候邮箱处于登陆状态，第三方就可以利用这个登陆状态，伪造带有正确 Cookie 的 http 请求，绕过后台验证，冒充用户进行一些操作</p><h2 id="发起-csrf-攻击有三个必要条件" tabindex="-1">发起 CSRF 攻击有三个必要条件 <a class="header-anchor" href="#发起-csrf-攻击有三个必要条件" aria-label="Permalink to &quot;发起 CSRF 攻击有三个必要条件&quot;">​</a></h2><ul><li><p>目标网站有 CSRF 漏洞</p></li><li><p>用户登录过目标网站，并且浏览器保存了登陆状态。</p></li><li><p>用户主动打开第三方站点。</p></li></ul><p>CSRF 本质上是利用进行 HTTP 同源请求时会携带 Cookie 信息这一特点，实现冒充用户。</p><h2 id="解决方法-1" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法-1" aria-label="Permalink to &quot;解决方法&quot;">​</a></h2><ul><li><p>Cookie Hashing（服务器生成 Cookie 传递给客户端时会生成一个随机数存在其中）。最简单有效方式，因为攻击者理论上无法获取第三方的Cookie，所以伪造 Cookie 失败，无法通过用户验证。</p></li><li><p>携带 token。客户端向服务器请求 token（令牌），服务器返回 token 给客户端，并且客户端在之后的所有请求中都要带上 token 以作身份验证。</p></li><li><p>Origin 和 Referer。服务器验证 Referer 是否从第三方网站发出来的，阻止第三方网站请求接口。但是这两者可以通过 ajax 自定义请求头的方式被伪造。</p></li></ul>',27),r=[l];function p(n,s,h,d,S,c){return e(),i("div",null,r)}const _=a(t,[["render",p]]);export{k as __pageData,_ as default};
