import{_ as e,o as a,c as t,R as i}from"./chunks/framework.d95bcf44.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{"0":"t","1":"i","2":"t","3":"l","4":"e","5":" ","6":"基","7":"础"},"headers":[],"relativePath":"studyCn/Vue2/index.md"}'),n={name:"studyCn/Vue2/index.md"},l=i(`<h2 id="vue-中的-key" tabindex="-1">Vue 中的 key <a class="header-anchor" href="#vue-中的-key" aria-label="Permalink to &quot;Vue 中的 key&quot;">​</a></h2><p>可以有效避免 vue 为了性能，<strong>就地复用</strong> 的机制，更快，更准确地拿到 Vnode节点。</p><h2 id="v-if-和-v-show-的区别" tabindex="-1">v-if 和 v-show 的区别 <a class="header-anchor" href="#v-if-和-v-show-的区别" aria-label="Permalink to &quot;v-if 和 v-show 的区别&quot;">​</a></h2><p>v-show 其实就是 <code>display:none</code> 的切换。而 v-if 是是否渲染该内容。</p><p>一般将频繁显隐的元素用 v-show ，反之则 v-if 。</p><p>并且，由于 v-if=&quot;false&quot; 时，内部组件是不会渲染的，所以可以将不重要的内容设置 false 。</p><p>需要时（或异步，比如 $nextTick）再设置为 true，这样可以优先渲染重要的其它内容，合理利用，可以进行性能优化。</p><h2 id="计算属性和侦听器的区别" tabindex="-1">计算属性和侦听器的区别 <a class="header-anchor" href="#计算属性和侦听器的区别" aria-label="Permalink to &quot;计算属性和侦听器的区别&quot;">​</a></h2><p>计算属性是通过某些变量，得到一个新的值，并且它相比侦听器，它有缓存，性能更好。</p><p>watch 侦听器是监听某个变量发生了改变之后，执行某些回调。</p><p>所以，只是需要动态值，那就用计算属性；需要知道值的改变后执行业务逻辑，才用 watch，用反或混用虽然可行，但都是不正确的用法。</p><h2 id="组件中-data-为什么是函数-而-new-vue-实例里-data-可以直接是一个对象" tabindex="-1">组件中 data 为什么是函数 而 new Vue 实例里，data 可以直接是一个对象 <a class="header-anchor" href="#组件中-data-为什么是函数-而-new-vue-实例里-data-可以直接是一个对象" aria-label="Permalink to &quot;组件中 data 为什么是函数 而 new Vue 实例里，data 可以直接是一个对象&quot;">​</a></h2><p>首先，因为 Vue 是 <code>SPA</code> ,所以，组件都是复用的。对象是引用关系，没有作用域隔离，所以，需要函数作用域来隔离。</p><p>而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p><h2 id="keep-alive-的理解" tabindex="-1">keep-alive 的理解 <a class="header-anchor" href="#keep-alive-的理解" aria-label="Permalink to &quot;keep-alive 的理解&quot;">​</a></h2><p><a href="https://juejin.cn/post/6844904084479164424" target="_blank" rel="noreferrer">浅析Vue系列之(一)详解keep-alive</a></p><h2 id="v-for-和-v-if-不能同时书写" tabindex="-1">v-for 和 v-if 不能同时书写 <a class="header-anchor" href="#v-for-和-v-if-不能同时书写" aria-label="Permalink to &quot;v-for 和 v-if 不能同时书写&quot;">​</a></h2><p>首先， v-for 的优先级高于 v-if ，也就是说，假设总计50条数据，即使经过v-if以后，只剩下25条显示，但是v-for早就循环了一遍50条数据。</p><p>为了提高性能，解决办法就是用一个计算属性先将数据过滤了以后，v-for循环过滤了之后的数据。</p><h2 id="router-path和name的区别" tabindex="-1">router path和name的区别 <a class="header-anchor" href="#router-path和name的区别" aria-label="Permalink to &quot;router path和name的区别&quot;">​</a></h2><p>name和path都可以实现跳转</p><ul><li><p>name和params 结合使用</p></li><li><p>path和query 结合使用</p></li><li><p>其实name和query也可以组合使用，但是参数无法正常传递接收</p></li><li><p>params传递参数在地址栏是看不到的，就跟post请求很像</p></li><li><p>query参数会显示在地址栏</p></li></ul><h2 id="npm-s-d-g" tabindex="-1">npm -s -d -g <a class="header-anchor" href="#npm-s-d-g" aria-label="Permalink to &quot;npm -s -d -g&quot;">​</a></h2><ol><li><p>npm install XXX -s npm install XXX -s 相当于 npm install -S 相当于 npm install --save</p><pre><code> 这样安装是局部安装的，会写进package.json文件中的dependencie里。

 dependencies： 表示生产环境下的依赖管理；

 说白了你安装一个库如果是用来构建你的项目的，比如echarts、element-ui，是实际在项目中起作用，就可以使用 -s 来安装。
</code></pre></li><li><p>npm install XXX -d npm install XXX -d 相当于 npm install -D 相当于 npm install --save-dev</p><pre><code> 这样安装是局部安装的，会写进package.json文件中的devDependencies 里。

 devDependencies ：表示开发环境下的依赖管理；

 如果你安装的库是用来打包的、解析代码的，比如webpack、babel，就可以用 -d 来安装，项目上线了，这些库就没用了，不然留这些库给用户自己来打包和解析代码嘛。               
</code></pre></li><li><p>npm install XXX -g npm install XXX -g 表示全局安装，安装一次过后，你就可以在其他直接用啦。</p></li><li><p>npm install XXX npm install XXX 什么都不加的时候</p><pre><code> npm 5开始通过npm install 什么都不加 和 npm install --save一样，都是局部安装并会把模块自动写入package.json中的dependencies里。
</code></pre></li></ol><hr><h2 id="进阶-基础" tabindex="-1">进阶 基础 <a class="header-anchor" href="#进阶-基础" aria-label="Permalink to &quot;进阶 基础&quot;">​</a></h2><h2 id="nexttick" tabindex="-1">nextTick <a class="header-anchor" href="#nexttick" aria-label="Permalink to &quot;nextTick&quot;">​</a></h2><h4 id="为什么会有nexttick这个东西的存在" tabindex="-1">为什么会有nextTick这个东西的存在? <a class="header-anchor" href="#为什么会有nexttick这个东西的存在" aria-label="Permalink to &quot;为什么会有nextTick这个东西的存在?&quot;">​</a></h4><p>因为 vue 采用的异步更新策略，当监听到数据发生变化的时候不会立即去更新DOM， 而是开启一个任务队列，并缓存在同一事件循环中发生的所有数据变更; 这种做法带来的好处就是可以将多次数据更新合并成一次，减少操作DOM的次数， 如果不采用这种方法，假设数据改变100次就要去更新100次DOM，而频繁的DOM更新是很耗性能的；</p><h4 id="宏任务" tabindex="-1">宏任务 <a class="header-anchor" href="#宏任务" aria-label="Permalink to &quot;宏任务&quot;">​</a></h4><p>script （主代码块）、setTimeout 、setInterval 、setImmediate 、I/O 、UI rendering</p><h4 id="微任务" tabindex="-1">微任务 <a class="header-anchor" href="#微任务" aria-label="Permalink to &quot;微任务&quot;">​</a></h4><p>script process.nextTick（Nodejs） 、promise 、Object.observe 、MutationObserver</p><h4 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h4><ul><li><p>宏任务是每次执行栈执行的代码（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p></li><li><p>浏览器为了能够使得JS引擎线程与GUI渲染线程有序切换，会在当前宏任务结束之后，下一个宏任务执行开始之前，对页面进行重新渲染（宏任务 &gt; 渲染 &gt; 宏任务 &gt; ...）</p></li><li><p>微任务是在当前宏任务执行结束之后立即执行的任务（在当前 宏任务执行之后，UI渲染之前执行的任务）。微任务的响应速度相比setTimeout（下一个宏任务）会更快，因为无需等待UI渲染。</p></li></ul><p>当前宏任务执行后，会将在它执行期间产生的所有微任务都执行一遍。</p><h4 id="流程" tabindex="-1">流程 <a class="header-anchor" href="#流程" aria-label="Permalink to &quot;流程&quot;">​</a></h4><ol><li>执行一个宏任务（首次执行的主代码块或者任务队列中的回调函数）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有任务（依次执行）</li><li>JS引擎线程挂起，GUI线程执行渲染</li><li>GUI线程渲染完毕后挂起，JS引擎线程执行任务队列中的下一个宏任务</li></ol><h4 id="nexttick原理" tabindex="-1">nextTick原理 <a class="header-anchor" href="#nexttick原理" aria-label="Permalink to &quot;nextTick原理&quot;">​</a></h4><ul><li><p>Vue中 数据变化 =&gt; DOM变化 是异步过程，一旦观察到数据变化，Vue就会开启一个任务队列，然后把在同一个事件循环 (Event loop) 中观察到数据变化的 Watcher（Vue源码中的Wacher类是用来更新Dep类收集到的依赖的）推送进这个队列。</p></li><li><p>如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOM操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。</p></li><li><p>nextTick的作用是为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback)，JS是单线程的，拥有事件循环机制，nextTick的实现就是利用了事件循环的宏任务和微任务。</p></li></ul><h4 id="dom操作是异步的吗" tabindex="-1">dom操作是异步的吗 <a class="header-anchor" href="#dom操作是异步的吗" aria-label="Permalink to &quot;dom操作是异步的吗&quot;">​</a></h4><p>dom的操作其实是同步的，但是渲染是异步的。因为JavaScript引擎线程跟GUI渲染线程是互斥的，即我执行的时候，你就靠边站，我执行完你才能执行。</p>`,42),r=[l];function o(p,s,d,h,c,u){return a(),t("div",null,r)}const v=e(n,[["render",o]]);export{k as __pageData,v as default};
